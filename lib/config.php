<?php
/**
 * Spamtroll Configuration Manager
 *
 * Manages the plugin data dir config file (bash format).
 * Used by both the DirectAdmin admin panel and the Exim check script.
 */

class SpamtrollConfig
{
    private static $configFile = '/usr/local/directadmin/plugins/spamtroll/data/spamtroll.conf';
    private static $logFile = '/var/log/spamtroll.log';

    /**
     * Default configuration values
     */
    private static $defaults = [
        'enabled' => false,
        'api_key' => '',
        'api_url' => 'https://api.spamtroll.io/api/v1/scan/check',
        'log_level' => 'info',
        'timeout' => 5,
        'whitelist' => '',
        'blacklist' => '',
    ];

    /**
     * Load configuration from file
     *
     * @return array Configuration values
     */
    public static function load(): array
    {
        $config = self::$defaults;

        if (!file_exists(self::$configFile)) {
            return $config;
        }

        $content = @file_get_contents(self::$configFile);
        if ($content === false) {
            return $config;
        }

        // Parse bash format: KEY=value or KEY="value"
        $patterns = [
            'enabled' => '/^ENABLED=(\w+)/m',
            'api_key' => '/^API_KEY="([^"]*)"$/m',
            'api_url' => '/^API_URL="([^"]*)"$/m',
            'log_level' => '/^LOG_LEVEL="([^"]*)"$/m',
            'timeout' => '/^TIMEOUT=(\d+)/m',
            'whitelist' => '/^WHITELIST="([^"]*)"$/m',
            'blacklist' => '/^BLACKLIST="([^"]*)"$/m',
        ];

        foreach ($patterns as $key => $pattern) {
            if (preg_match($pattern, $content, $matches)) {
                $value = trim($matches[1]);

                if ($key === 'enabled') {
                    $config[$key] = ($value === 'true');
                } elseif ($key === 'timeout') {
                    $config[$key] = (int)$value;
                } else {
                    $config[$key] = $value;
                }
            }
        }

        return $config;
    }

    /**
     * Save configuration to file
     *
     * @param array $config Configuration values to save
     * @return bool True on success
     */
    public static function save(array $config): bool
    {
        // Merge with defaults
        $config = array_merge(self::$defaults, $config);

        // Build config file content (bash format)
        $enabled = $config['enabled'] ? 'true' : 'false';
        $content = <<<EOF
# Spamtroll Configuration
# Generated by DirectAdmin plugin
# Do not edit manually - use the admin panel

ENABLED={$enabled}
API_KEY="{$config['api_key']}"
API_URL="{$config['api_url']}"
LOG_LEVEL="{$config['log_level']}"
TIMEOUT={$config['timeout']}
WHITELIST="{$config['whitelist']}"
BLACKLIST="{$config['blacklist']}"
EOF;

        // Ensure directory exists
        $dir = dirname(self::$configFile);
        if (!is_dir($dir)) {
            @mkdir($dir, 0770, true);
        }

        // Write file
        $result = @file_put_contents(self::$configFile, $content);
        if ($result === false) {
            return false;
        }

        // Set secure permissions (readable by root/exim only)
        @chmod(self::$configFile, 0660);

        return true;
    }

    /**
     * Test API connection
     *
     * @return array Result with 'success' boolean and 'message' or 'error'
     */
    public static function testConnection(): array
    {
        $config = self::load();

        if (empty($config['api_key'])) {
            return [
                'success' => false,
                'error' => 'API key not configured',
            ];
        }

        // Use the status endpoint for testing
        $statusUrl = str_replace('/scan/check', '/scan/status', $config['api_url']);

        $ch = curl_init();
        curl_setopt_array($ch, [
            CURLOPT_URL => $statusUrl,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_TIMEOUT => 10,
            CURLOPT_HTTPHEADER => [
                'X-API-Key: ' . $config['api_key'],
                'Content-Type: application/json',
            ],
        ]);

        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $curlError = curl_error($ch);
        curl_close($ch);

        if (!empty($curlError)) {
            return [
                'success' => false,
                'error' => 'Connection failed: ' . $curlError,
            ];
        }

        if ($httpCode === 200) {
            return [
                'success' => true,
                'message' => 'Connection successful',
                'data' => json_decode($response, true),
            ];
        } elseif ($httpCode === 401) {
            return [
                'success' => false,
                'error' => 'Invalid API key',
            ];
        } elseif ($httpCode === 403) {
            return [
                'success' => false,
                'error' => 'API key not authorized',
            ];
        } else {
            return [
                'success' => false,
                'error' => "API returned HTTP {$httpCode}",
                'response' => $response,
            ];
        }
    }

    /**
     * Get log file path
     *
     * @return string Log file path
     */
    public static function getLogFile(): string
    {
        return self::$logFile;
    }

    /**
     * Get config file path
     *
     * @return string Config file path
     */
    public static function getConfigFile(): string
    {
        return self::$configFile;
    }

    /**
     * Check if configuration exists
     *
     * @return bool True if config file exists
     */
    public static function exists(): bool
    {
        return file_exists(self::$configFile);
    }

    /**
     * Validate API key format
     *
     * @param string $apiKey API key to validate
     * @return bool True if valid format
     */
    public static function validateApiKey(string $apiKey): bool
    {
        // API key should be alphanumeric, at least 20 characters
        return preg_match('/^[a-zA-Z0-9_-]{20,}$/', $apiKey) === 1;
    }

    /**
     * Validate a comma-separated list of emails/domains
     *
     * @param string $list Comma-separated list
     * @return bool True if all entries are valid emails or domains
     */
    public static function validateList(string $list): bool
    {
        if (trim($list) === '') {
            return true;
        }

        $entries = array_map('trim', explode(',', $list));
        foreach ($entries as $entry) {
            if ($entry === '') {
                continue;
            }
            // Valid: user@example.com or example.com or @example.com
            if (!preg_match('/^@?[a-zA-Z0-9._-]+(\.[a-zA-Z]{2,})+$/', $entry)
                && !preg_match('/^[a-zA-Z0-9._+-]+@[a-zA-Z0-9._-]+\.[a-zA-Z]{2,}$/', $entry)) {
                return false;
            }
        }

        return true;
    }
}
